//===-- FgpuInstrFPU.td - Fgpu FPU Instruction Information -*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file describes the Fgpu FPU instruction set.
//
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Floating Point Instructions
// ------------------------
// * 64bit fp:
//    - 32 64-bit registers (default mode)
//    - 16 even 32-bit registers (32-bit compatible mode) for
//      single and double access.
// * 32bit fp:
//    - 16 even 32-bit registers - single and double (aliased)
//    - 32 32-bit registers (within single-only mode)
//===----------------------------------------------------------------------===//

// Floating Point Compare and Branch
def SDT_FgpuFPBrcond : SDTypeProfile<0, 3, [SDTCisInt<0>,
                                            SDTCisVT<1, i32>,
                                            SDTCisVT<2, OtherVT>]>;
def SDT_FgpuFPCmp : SDTypeProfile<0, 3, [SDTCisSameAs<0, 1>, SDTCisFP<1>,
                                         SDTCisVT<2, i32>]>;
def SDT_FgpuCMovFP : SDTypeProfile<1, 3, [SDTCisSameAs<0, 1>, SDTCisVT<2, i32>,
                                          SDTCisSameAs<1, 3>]>;
def SDT_FgpuTruncIntFP : SDTypeProfile<1, 1, [SDTCisFP<0>, SDTCisFP<1>]>;
def SDT_FgpuBuildPairF64 : SDTypeProfile<1, 2, [SDTCisVT<0, f64>,
                                                SDTCisVT<1, i32>,
                                                SDTCisSameAs<1, 2>]>;
def SDT_FgpuExtractElementF64 : SDTypeProfile<1, 2, [SDTCisVT<0, i32>,
                                                     SDTCisVT<1, f64>,
                                                     SDTCisVT<2, i32>]>;

def SDT_FgpuMTC1_D64 : SDTypeProfile<1, 1, [SDTCisVT<0, f64>,
                                            SDTCisVT<1, i32>]>;

def FgpuFPCmp : SDNode<"FgpuISD::FPCmp", SDT_FgpuFPCmp, [SDNPOutGlue]>;
def FgpuCMovFP_T : SDNode<"FgpuISD::CMovFP_T", SDT_FgpuCMovFP, [SDNPInGlue]>;
def FgpuCMovFP_F : SDNode<"FgpuISD::CMovFP_F", SDT_FgpuCMovFP, [SDNPInGlue]>;
def FgpuFPBrcond : SDNode<"FgpuISD::FPBrcond", SDT_FgpuFPBrcond,
                          [SDNPHasChain, SDNPOptInGlue]>;
def FgpuTruncIntFP : SDNode<"FgpuISD::TruncIntFP", SDT_FgpuTruncIntFP>;
def FgpuBuildPairF64 : SDNode<"FgpuISD::BuildPairF64", SDT_FgpuBuildPairF64>;
def : GINodeEquiv<G_MERGE_VALUES, FgpuBuildPairF64>;
def FgpuExtractElementF64 : SDNode<"FgpuISD::ExtractElementF64",
                                   SDT_FgpuExtractElementF64>;

def FgpuMTC1_D64 : SDNode<"FgpuISD::MTC1_D64", SDT_FgpuMTC1_D64>;

// Operand for printing out a condition code.
let PrintMethod = "printFCCOperand", DecoderMethod = "DecodeCondCode" in
  def condcode : Operand<i32>;

//===----------------------------------------------------------------------===//
// Feature predicates.
//===----------------------------------------------------------------------===//

def IsFP64bit        : Predicate<"Subtarget->isFP64bit()">,
                       AssemblerPredicate<(all_of FeatureFP64Bit)>;
def NotFP64bit       : Predicate<"!Subtarget->isFP64bit()">,
                       AssemblerPredicate<(all_of (not FeatureFP64Bit))>;
def IsSingleFloat    : Predicate<"Subtarget->isSingleFloat()">,
                       AssemblerPredicate<(all_of FeatureSingleFloat)>;
def IsNotSingleFloat : Predicate<"!Subtarget->isSingleFloat()">,
                       AssemblerPredicate<(all_of (not FeatureSingleFloat))>;
def IsNotSoftFloat   : Predicate<"!Subtarget->useSoftFloat()">,
                       AssemblerPredicate<(all_of (not FeatureSoftFloat))>;
def HasFgpu3D        : Predicate<"Subtarget->has3D()">,
                       AssemblerPredicate<(all_of FeatureFgpu3D)>;

//===----------------------------------------------------------------------===//
// Fgpu FGR size adjectives.
// They are mutually exclusive.
//===----------------------------------------------------------------------===//

class FGR_32 { list<Predicate> FGRPredicates = [NotFP64bit]; }
class FGR_64 { list<Predicate> FGRPredicates = [IsFP64bit]; }
class HARDFLOAT { list<Predicate> HardFloatPredicate = [IsNotSoftFloat]; }

//===----------------------------------------------------------------------===//

// FP immediate patterns.
def fpimm0 : PatLeaf<(fpimm), [{
  return N->isExactlyValue(+0.0);
}]>;

def fpimm0neg : PatLeaf<(fpimm), [{
  return N->isExactlyValue(-0.0);
}]>;

//===----------------------------------------------------------------------===//
// Instruction Class Templates
//
// A set of multiclasses is used to address the register usage.
//
// S32 - single precision in 16 32bit even fp registers
//       single precision in 32 32bit fp registers in SingleOnly mode
// S64 - single precision in 32 64bit fp registers (In64BitMode)
// D32 - double precision in 16 32bit even fp registers
// D64 - double precision in 32 64bit fp registers (In64BitMode)
//
// Only S32 and D32 are supported right now.
//===----------------------------------------------------------------------===//
class ADDS_FT<string opstr, RegisterOperand RC, InstrItinClass Itin, bit IsComm,
              SDPatternOperator OpNode= null_frag> :
  InstSE<(outs RC:$fd), (ins RC:$fs, RC:$ft),
         !strconcat(opstr, "\t$fd, $fs, $ft"),
         [(set RC:$fd, (OpNode RC:$fs, RC:$ft))], Itin, FrmFR, opstr>,
  HARDFLOAT {
  let isCommutable = IsComm;
}

multiclass ADDS_M<string opstr, InstrItinClass Itin, bit IsComm,
                  SDPatternOperator OpNode = null_frag> {
  def _D32 :  ADDS_FT<opstr, AFGR64Opnd, Itin, IsComm, OpNode>, FGR_32;
  def _D64 : ADDS_FT<opstr, FGR64Opnd, Itin, IsComm, OpNode>, FGR_64 {
    string DecoderNamespace = "FgpuFP64";
  }
}

class ABSS_FT<string opstr, RegisterOperand DstRC, RegisterOperand SrcRC,
              InstrItinClass Itin, SDPatternOperator OpNode= null_frag> :
  InstSE<(outs DstRC:$fd), (ins SrcRC:$fs), !strconcat(opstr, "\t$fd, $fs"),
         [(set DstRC:$fd, (OpNode SrcRC:$fs))], Itin, FrmFR, opstr>,
  HARDFLOAT,
  NeverHasSideEffects;

class CVT_PS_S_FT<string opstr, RegisterOperand DstRC, RegisterOperand SrcRC,
                  InstrItinClass Itin, bit IsComm,
                  SDPatternOperator OpNode = null_frag> :
  InstSE<(outs DstRC:$fd), (ins SrcRC:$fs, SrcRC:$ft),
         !strconcat(opstr, "\t$fd, $fs, $ft"),
         [(set DstRC:$fd, (OpNode SrcRC:$fs, SrcRC:$ft))], Itin, FrmFR, opstr>,
  HARDFLOAT {
  let isCommutable = IsComm;
}

multiclass ABSS_M<string opstr, InstrItinClass Itin,
                  SDPatternOperator OpNode= null_frag> {
  def _D32 :  ABSS_FT<opstr, AFGR64Opnd, AFGR64Opnd, Itin, OpNode>,
             FGR_32;
  def _D64 :  ABSS_FT<opstr, FGR64Opnd, FGR64Opnd, Itin, OpNode>,
             FGR_64 {
    string DecoderNamespace = "FgpuFP64";
  }
}

multiclass ROUND_M<string opstr, InstrItinClass Itin> {
  def _D32 :  ABSS_FT<opstr, FGR32Opnd, AFGR64Opnd, Itin>, FGR_32;
  def _D64 :  ABSS_FT<opstr, FGR32Opnd, FGR64Opnd, Itin>, FGR_64 {
    let DecoderNamespace = "FgpuFP64";
  }
}

class MFC1_FT<string opstr, RegisterOperand DstRC, RegisterOperand SrcRC,
              InstrItinClass Itin, SDPatternOperator OpNode= null_frag> :
  InstSE<(outs DstRC:$rt), (ins SrcRC:$fs), !strconcat(opstr, "\t$rt, $fs"),
         [(set DstRC:$rt, (OpNode SrcRC:$fs))], Itin, FrmFR, opstr>, HARDFLOAT {
  let isMoveReg = 1;
}

class MTC1_FT<string opstr, RegisterOperand DstRC, RegisterOperand SrcRC,
              InstrItinClass Itin, SDPatternOperator OpNode= null_frag> :
  InstSE<(outs DstRC:$fs), (ins SrcRC:$rt), !strconcat(opstr, "\t$rt, $fs"),
         [(set DstRC:$fs, (OpNode SrcRC:$rt))], Itin, FrmFR, opstr>, HARDFLOAT {
  let isMoveReg = 1;
}

class MTC1_64_FT<string opstr, RegisterOperand DstRC, RegisterOperand SrcRC,
                 InstrItinClass Itin> :
  InstSE<(outs DstRC:$fs), (ins DstRC:$fs_in, SrcRC:$rt),
         !strconcat(opstr, "\t$rt, $fs"), [], Itin, FrmFR, opstr>, HARDFLOAT {
  // $fs_in is part of a white lie to work around a widespread bug in the FPU
  // implementation. See expandBuildPairF64 for details.
  let Constraints = "$fs = $fs_in";
}

class LW_FT<string opstr, RegisterOperand RC, DAGOperand MO,
            InstrItinClass Itin, SDPatternOperator OpNode = null_frag> :
  InstSE<(outs RC:$rt), (ins MO:$addr), !strconcat(opstr, "\t$rt, $addr"),
         [(set RC:$rt, (OpNode addrDefault:$addr))], Itin, FrmFI, opstr>,
  HARDFLOAT {
  let DecoderMethod = "DecodeFMem";
  let mayLoad = 1;
}

class SW_FT<string opstr, RegisterOperand RC, DAGOperand MO,
            InstrItinClass Itin, SDPatternOperator OpNode = null_frag> :
  InstSE<(outs), (ins RC:$rt, MO:$addr), !strconcat(opstr, "\t$rt, $addr"),
         [(OpNode RC:$rt, addrDefault:$addr)], Itin, FrmFI, opstr>, HARDFLOAT {
  let DecoderMethod = "DecodeFMem";
  let mayStore = 1;
}

class MADDS_FT<string opstr, RegisterOperand RC, InstrItinClass Itin,
               SDPatternOperator OpNode = null_frag> :
  InstSE<(outs RC:$fd), (ins RC:$fr, RC:$fs, RC:$ft),
         !strconcat(opstr, "\t$fd, $fr, $fs, $ft"),
         [(set RC:$fd, (OpNode (fmul RC:$fs, RC:$ft), RC:$fr))], Itin,
         FrmFR, opstr>, HARDFLOAT;

class NMADDS_FT<string opstr, RegisterOperand RC, InstrItinClass Itin,
                SDPatternOperator OpNode = null_frag> :
  InstSE<(outs RC:$fd), (ins RC:$fr, RC:$fs, RC:$ft),
         !strconcat(opstr, "\t$fd, $fr, $fs, $ft"),
         [(set RC:$fd, (fsub fpimm0, (OpNode (fmul RC:$fs, RC:$ft), RC:$fr)))],
         Itin, FrmFR, opstr>, HARDFLOAT;

class LWXC1_FT<string opstr, RegisterOperand DRC,
               InstrItinClass Itin, SDPatternOperator OpNode = null_frag> :
  InstSE<(outs DRC:$fd), (ins PtrRC:$base, PtrRC:$index),
         !strconcat(opstr, "\t$fd, ${index}(${base})"),
         [(set DRC:$fd, (OpNode (add iPTR:$base, iPTR:$index)))], Itin,
         FrmFI, opstr>, HARDFLOAT {
  let AddedComplexity = 20;
}

class SWXC1_FT<string opstr, RegisterOperand DRC,
               InstrItinClass Itin, SDPatternOperator OpNode = null_frag> :
  InstSE<(outs), (ins DRC:$fs, PtrRC:$base, PtrRC:$index),
         !strconcat(opstr, "\t$fs, ${index}(${base})"),
         [(OpNode DRC:$fs, (add iPTR:$base, iPTR:$index))], Itin,
         FrmFI, opstr>, HARDFLOAT {
  let AddedComplexity = 20;
}

class BC1F_FT<string opstr, DAGOperand opnd, InstrItinClass Itin,
              SDPatternOperator Op = null_frag> :
  InstSE<(outs), (ins FCCRegsOpnd:$fcc, opnd:$offset),
         !strconcat(opstr, "\t$fcc, $offset"),
         [(FgpuFPBrcond Op, FCCRegsOpnd:$fcc, bb:$offset)], Itin,
         FrmFI, opstr>, HARDFLOAT {
  let isBranch = 1;
  let isTerminator = 1;
  let hasDelaySlot = 1;
  let Defs = [AT];
  let hasFCCRegOperand = 1;
}

class BC1XL_FT<string opstr, DAGOperand opnd, InstrItinClass Itin> :
  InstSE<(outs), (ins FCCRegsOpnd:$fcc, opnd:$offset),
         !strconcat(opstr, "\t$fcc, $offset"), [], Itin,
         FrmFI, opstr>, HARDFLOAT {
  let isBranch = 1;
  let isTerminator = 1;
  let hasDelaySlot = 1;
  let Defs = [AT];
  let hasFCCRegOperand = 1;
}

class CEQS_FT<string typestr, RegisterClass RC, InstrItinClass Itin,
              SDPatternOperator OpNode = null_frag>  :
  InstSE<(outs), (ins RC:$fs, RC:$ft, condcode:$cond),
         !strconcat("c.$cond.", typestr, "\t$fs, $ft"),
         [(OpNode RC:$fs, RC:$ft, imm:$cond)], Itin, FrmFR,
         !strconcat("c.$cond.", typestr)>, HARDFLOAT {
  let Defs = [FCC0];
  let isCodeGenOnly = 1;
  let hasFCCRegOperand = 1;
}


// Note: FGPU-IV introduced $fcc1-$fcc7 and renamed FCSR31[23] $fcc0. Rather
//       duplicating the instruction definition for FGPU1 - FGPU3, we expand
//       c.cond.ft if necessary, and reject it after constructing the
//       instruction if the ISA doesn't support it.
class C_COND_FT<string CondStr, string Typestr, RegisterOperand RC,
                InstrItinClass itin>  :
   InstSE<(outs FCCRegsOpnd:$fcc), (ins RC:$fs, RC:$ft),
          !strconcat("c.", CondStr, ".", Typestr, "\t$fcc, $fs, $ft"), [], itin,
          FrmFR>, HARDFLOAT {
  let isCompare = 1;
  let hasFCCRegOperand = 1;
}


multiclass C_COND_M<string TypeStr, RegisterOperand RC, bits<5> fmt,
                    InstrItinClass itin> {
  def C_F_#NAME :  C_COND_FT<"f", TypeStr, RC, itin>,
                  C_COND_FM<fmt, 0> {
    let BaseOpcode = "c.f."#NAME;
    let isCommutable = 1;
  }
  def C_UN_#NAME :  C_COND_FT<"un", TypeStr, RC, itin>,
                   C_COND_FM<fmt, 1> {
    let BaseOpcode = "c.un."#NAME;
    let isCommutable = 1;
  }
  def C_EQ_#NAME :  C_COND_FT<"eq", TypeStr, RC, itin>,
                   C_COND_FM<fmt, 2> {
    let BaseOpcode = "c.eq."#NAME;
    let isCommutable = 1;
  }
  def C_UEQ_#NAME :  C_COND_FT<"ueq", TypeStr, RC, itin>,
                    C_COND_FM<fmt, 3> {
    let BaseOpcode = "c.ueq."#NAME;
    let isCommutable = 1;
  }
  def C_OLT_#NAME :  C_COND_FT<"olt", TypeStr, RC, itin>,
                    C_COND_FM<fmt, 4> {
    let BaseOpcode = "c.olt."#NAME;
  }
  def C_ULT_#NAME :  C_COND_FT<"ult", TypeStr, RC, itin>,
                    C_COND_FM<fmt, 5> {
    let BaseOpcode = "c.ult."#NAME;
  }
  def C_OLE_#NAME :  C_COND_FT<"ole", TypeStr, RC, itin>,
                    C_COND_FM<fmt, 6> {
    let BaseOpcode = "c.ole."#NAME;
  }
  def C_ULE_#NAME :  C_COND_FT<"ule", TypeStr, RC, itin>,
                     C_COND_FM<fmt, 7> {
    let BaseOpcode = "c.ule."#NAME;
  }
  def C_SF_#NAME :  C_COND_FT<"sf", TypeStr, RC, itin>,
                   C_COND_FM<fmt, 8> {
    let BaseOpcode = "c.sf."#NAME;
    let isCommutable = 1;
  }
  def C_NGLE_#NAME :  C_COND_FT<"ngle", TypeStr, RC, itin>,
                     C_COND_FM<fmt, 9> {
    let BaseOpcode = "c.ngle."#NAME;
  }
  def C_SEQ_#NAME :  C_COND_FT<"seq", TypeStr, RC, itin>,
                    C_COND_FM<fmt, 10> {
    let BaseOpcode = "c.seq."#NAME;
    let isCommutable = 1;
  }
  def C_NGL_#NAME :  C_COND_FT<"ngl", TypeStr, RC, itin>,
                    C_COND_FM<fmt, 11> {
    let BaseOpcode = "c.ngl."#NAME;
  }
  def C_LT_#NAME :  C_COND_FT<"lt", TypeStr, RC, itin>,
                   C_COND_FM<fmt, 12> {
    let BaseOpcode = "c.lt."#NAME;
  }
  def C_NGE_#NAME :  C_COND_FT<"nge", TypeStr, RC, itin>,
                    C_COND_FM<fmt, 13> {
    let BaseOpcode = "c.nge."#NAME;
  }
  def C_LE_#NAME :  C_COND_FT<"le", TypeStr, RC, itin>,
                   C_COND_FM<fmt, 14> {
    let BaseOpcode = "c.le."#NAME;
  }
  def C_NGT_#NAME :  C_COND_FT<"ngt", TypeStr, RC, itin>,
                    C_COND_FM<fmt, 15> {
    let BaseOpcode = "c.ngt."#NAME;
  }
}

defm S : C_COND_M<"s", FGR32Opnd, 16, II_C_CC_S>, ISA_FGPU1_NOT_32R6_64R6;
defm D32 : C_COND_M<"d", AFGR64Opnd, 17, II_C_CC_D>, ISA_FGPU1_NOT_32R6_64R6,
           FGR_32;
let DecoderNamespace = "FgpuFP64" in
defm D64 : C_COND_M<"d", FGR64Opnd, 17, II_C_CC_D>, ISA_FGPU1_NOT_32R6_64R6,
           FGR_64;


//===----------------------------------------------------------------------===//
// Floating Point Instructions
//===----------------------------------------------------------------------===//

  def ROUND_W_S :
                  ABSS_FT<"round.w.s", FGR32Opnd, FGR32Opnd, II_ROUND>,
                  ABSS_FM<0xc, 16>, ISA_FGPU2;
  defm ROUND_W  : ROUND_M<"round.w.d", II_ROUND>, ABSS_FM<0xc, 17>, ISA_FGPU2;
  def TRUNC_W_S :  
                  ABSS_FT<"trunc.w.s", FGR32Opnd, FGR32Opnd, II_TRUNC>,
                  ABSS_FM<0xd, 16>, ISA_FGPU2;
  def CEIL_W_S  :  
                  ABSS_FT<"ceil.w.s", FGR32Opnd, FGR32Opnd, II_CEIL>,
                  ABSS_FM<0xe, 16>, ISA_FGPU2;
  def FLOOR_W_S :  
                  ABSS_FT<"floor.w.s", FGR32Opnd, FGR32Opnd, II_FLOOR>,
                  ABSS_FM<0xf, 16>, ISA_FGPU2;
  def CVT_W_S   :  ABSS_FT<"cvt.w.s", FGR32Opnd, FGR32Opnd, II_CVT>,
                  ABSS_FM<0x24, 16>, ISA_FGPU1;

  defm TRUNC_W : ROUND_M<"trunc.w.d", II_TRUNC>, ABSS_FM<0xd, 17>, ISA_FGPU2;
  defm CEIL_W  : ROUND_M<"ceil.w.d", II_CEIL>, ABSS_FM<0xe, 17>, ISA_FGPU2;
  defm FLOOR_W : ROUND_M<"floor.w.d", II_FLOOR>, ABSS_FM<0xf, 17>, ISA_FGPU2;
  defm CVT_W   : ROUND_M<"cvt.w.d", II_CVT>, ABSS_FM<0x24, 17>, ISA_FGPU1;




  def RECIP_S :  ABSS_FT<"recip.s", FGR32Opnd, FGR32Opnd, II_RECIP_S>,
                ABSS_FM<0b010101, 0x10>, INSN_FGPU4_32R2;
  def RECIP_D32 :  ABSS_FT<"recip.d", AFGR64Opnd, AFGR64Opnd, II_RECIP_D>,
                  ABSS_FM<0b010101, 0x11>, INSN_FGPU4_32R2, FGR_32 {
    let BaseOpcode = "RECIP_D32";
  }
  let DecoderNamespace = "FgpuFP64" in
    def RECIP_D64 :  ABSS_FT<"recip.d", FGR64Opnd, FGR64Opnd,
                                   II_RECIP_D>, ABSS_FM<0b010101, 0x11>,
                    INSN_FGPU4_32R2, FGR_64;
  def RSQRT_S :  ABSS_FT<"rsqrt.s", FGR32Opnd, FGR32Opnd, II_RSQRT_S>,
                ABSS_FM<0b010110, 0x10>, INSN_FGPU4_32R2;
  def RSQRT_D32 :  ABSS_FT<"rsqrt.d", AFGR64Opnd, AFGR64Opnd, II_RSQRT_D>,
                  ABSS_FM<0b010110, 0x11>, INSN_FGPU4_32R2, FGR_32 {
    let BaseOpcode = "RSQRT_D32";
  }
  let DecoderNamespace = "FgpuFP64" in
    def RSQRT_D64 :  ABSS_FT<"rsqrt.d", FGR64Opnd, FGR64Opnd,
                                   II_RSQRT_D>, ABSS_FM<0b010110, 0x11>,
                    INSN_FGPU4_32R2, FGR_64;


let DecoderNamespace = "FgpuFP64" in {
  def ROUND_L_S : ABSS_FT<"round.l.s", FGR64Opnd, FGR32Opnd, II_ROUND>,
                  ABSS_FM<0x8, 16>, ISA_FGPU2, FGR_64;
  def ROUND_L_D64 : ABSS_FT<"round.l.d", FGR64Opnd, FGR64Opnd, II_ROUND>,
                    ABSS_FM<0x8, 17>, INSN_FGPU3_32, FGR_64;
  def TRUNC_L_S : ABSS_FT<"trunc.l.s", FGR64Opnd, FGR32Opnd, II_TRUNC>,
                  ABSS_FM<0x9, 16>, ISA_FGPU2, FGR_64;
  def TRUNC_L_D64 : ABSS_FT<"trunc.l.d", FGR64Opnd, FGR64Opnd, II_TRUNC>,
                    ABSS_FM<0x9, 17>, INSN_FGPU3_32, FGR_64;
  def CEIL_L_S  : ABSS_FT<"ceil.l.s", FGR64Opnd, FGR32Opnd, II_CEIL>,
                  ABSS_FM<0xa, 16>, ISA_FGPU2, FGR_64;
  def CEIL_L_D64 : ABSS_FT<"ceil.l.d", FGR64Opnd, FGR64Opnd, II_CEIL>,
                   ABSS_FM<0xa, 17>, INSN_FGPU3_32, FGR_64;
  def FLOOR_L_S : ABSS_FT<"floor.l.s", FGR64Opnd, FGR32Opnd, II_FLOOR>,
                  ABSS_FM<0xb, 16>, ISA_FGPU2, FGR_64;
  def FLOOR_L_D64 : ABSS_FT<"floor.l.d", FGR64Opnd, FGR64Opnd, II_FLOOR>,
                    ABSS_FM<0xb, 17>, INSN_FGPU3_32, FGR_64;
}

  def CVT_S_W :  ABSS_FT<"cvt.s.w", FGR32Opnd, FGR32Opnd, II_CVT>,
                ABSS_FM<0x20, 20>, ISA_FGPU1;
  def CVT_L_S :  ABSS_FT<"cvt.l.s", FGR64Opnd, FGR32Opnd, II_CVT>,
                ABSS_FM<0x25, 16>, INSN_FGPU3_32R2;
  def CVT_L_D64:  ABSS_FT<"cvt.l.d", FGR64Opnd, FGR64Opnd, II_CVT>,
                 ABSS_FM<0x25, 17>, INSN_FGPU3_32R2;

  def CVT_S_D32 :  ABSS_FT<"cvt.s.d", FGR32Opnd, AFGR64Opnd, II_CVT>,
                  ABSS_FM<0x20, 17>, ISA_FGPU1, FGR_32;
  def CVT_D32_S :  ABSS_FT<"cvt.d.s", AFGR64Opnd, FGR32Opnd, II_CVT>,
                  ABSS_FM<0x21, 16>, ISA_FGPU1, FGR_32;
  def CVT_D32_W :  ABSS_FT<"cvt.d.w", AFGR64Opnd, FGR32Opnd, II_CVT>,
                  ABSS_FM<0x21, 20>, ISA_FGPU1, FGR_32;

let DecoderNamespace = "FgpuFP64" in {
    def FADD_PS64   : ADDS_FT<"add.ps", FGR64Opnd, II_ADD_PS, 0>,
                      ADDS_FM<0x0, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def FMUL_PS64   : ADDS_FT<"mul.ps", FGR64Opnd, II_MUL_PS, 0>,
                      ADDS_FM<0x2, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def PLL_PS64    : ADDS_FT<"pll.ps", FGR64Opnd, II_CVT, 0>,
                      ADDS_FM<0x2C, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def PLU_PS64    : ADDS_FT<"plu.ps", FGR64Opnd, II_CVT, 0>,
                      ADDS_FM<0x2D, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def PUL_PS64    : ADDS_FT<"pul.ps", FGR64Opnd, II_CVT, 0>,
                      ADDS_FM<0x2E, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def PUU_PS64    : ADDS_FT<"puu.ps", FGR64Opnd, II_CVT, 0>,
                      ADDS_FM<0x2F, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def FSUB_PS64   : ADDS_FT<"sub.ps", FGR64Opnd, II_SUB_PS, 0>,
                      ADDS_FM<0x1, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;

    def CVT_S_PU64  : ABSS_FT<"cvt.s.pu", FGR32Opnd, FGR64Opnd, II_CVT>,
                      ABSS_FM<0x20, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def CVT_S_PL64  : ABSS_FT<"cvt.s.pl", FGR32Opnd, FGR64Opnd, II_CVT>,
                      ABSS_FM<0x28, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;

    def CVT_PS_S64  : CVT_PS_S_FT<"cvt.ps.s", FGR64Opnd, FGR32Opnd, II_CVT, 0>,
                      ADDS_FM<0x26, 16>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
}

let DecoderNamespace = "FgpuFP64" in {
  let AdditionalPredicates = [HasFgpu3D] in {
    def ADDR_PS64   : ADDS_FT<"addr.ps", FGR64Opnd, II_ADDR_PS, 0>,
                      ADDS_FM<0x18, 22>, ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def MULR_PS64   : ADDS_FT<"mulr.ps", FGR64Opnd, II_MULR_PS, 0>,
                      ADDS_FM<0x1a, 22>, ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def CVT_PS_PW64 : ABSS_FT<"cvt.ps.pw", FGR64Opnd, FGR64Opnd, II_CVT>,
                      ABSS_FM<0x26, 20>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
    def CVT_PW_PS64 : ABSS_FT<"cvt.pw.ps", FGR64Opnd, FGR64Opnd, II_CVT>,
                      ABSS_FM<0x24, 22>,
                      ISA_FGPU32R2_NOT_32R6_64R6, FGR_64;
  }
}

let DecoderNamespace = "FgpuFP64" in {
    def CVT_S_L   : ABSS_FT<"cvt.s.l", FGR32Opnd, FGR64Opnd, II_CVT>,
                    ABSS_FM<0x20, 21>, INSN_FGPU3_32R2, FGR_64;
    def CVT_S_D64 : ABSS_FT<"cvt.s.d", FGR32Opnd, FGR64Opnd, II_CVT>,
                    ABSS_FM<0x20, 17>, ISA_FGPU1, FGR_64;
    def CVT_D64_W : ABSS_FT<"cvt.d.w", FGR64Opnd, FGR32Opnd, II_CVT>,
                    ABSS_FM<0x21, 20>, ISA_FGPU1, FGR_64;
    def CVT_D64_S : ABSS_FT<"cvt.d.s", FGR64Opnd, FGR32Opnd, II_CVT>,
                    ABSS_FM<0x21, 16>, ISA_FGPU1, FGR_64;
    def CVT_D64_L : ABSS_FT<"cvt.d.l", FGR64Opnd, FGR64Opnd, II_CVT>,
                    ABSS_FM<0x21, 21>, INSN_FGPU3_32R2, FGR_64;
}

let isPseudo = 1, isCodeGenOnly = 1 in {
  def PseudoCVT_S_W : ABSS_FT<"", FGR32Opnd, GPR32Opnd, II_CVT>;
  def PseudoCVT_D32_W : ABSS_FT<"", AFGR64Opnd, GPR32Opnd, II_CVT>;
  def PseudoCVT_S_L : ABSS_FT<"", FGR64Opnd, GPR64Opnd, II_CVT>;
  def PseudoCVT_D64_W : ABSS_FT<"", FGR64Opnd, GPR32Opnd, II_CVT>;
  def PseudoCVT_D64_L : ABSS_FT<"", FGR64Opnd, GPR64Opnd, II_CVT>;
}

let AdditionalPredicates = [UseAbs] in {
  def FABS_S :  ABSS_FT<"abs.s", FGR32Opnd, FGR32Opnd, II_ABS, fabs>,
               ABSS_FM<0x5, 16>, ISA_FGPU1;
  defm FABS : ABSS_M<"abs.d", II_ABS, fabs>, ABSS_FM<0x5, 17>, ISA_FGPU1;
}

def FNEG_S :  ABSS_FT<"neg.s", FGR32Opnd, FGR32Opnd, II_NEG, fneg>,
             ABSS_FM<0x7, 16>, ISA_FGPU1;
  defm FNEG : ABSS_M<"neg.d", II_NEG, fneg>, ABSS_FM<0x7, 17>, ISA_FGPU1;

  def FSQRT_S :   ABSS_FT<"sqrt.s", FGR32Opnd, FGR32Opnd,
                II_SQRT_S, fsqrt>, ABSS_FM<0x4, 16>, ISA_FGPU2;
  defm FSQRT : ABSS_M<"sqrt.d", II_SQRT_D, fsqrt>, ABSS_FM<0x4, 17>, ISA_FGPU2;

// The odd-numbered registers are only referenced when doing loads,
// stores, and moves between floating-point and integer registers.
// When defining instructions, we reference all 32-bit registers,
// regardless of register aliasing.

/// Move Control Registers From/To CPU Registers
  def CFC1 :  MFC1_FT<"cfc1", GPR32Opnd, CCROpnd, II_CFC1>, MFC1_FM<2>,
             ISA_FGPU1;
  def CTC1 :  MTC1_FT<"ctc1", CCROpnd, GPR32Opnd, II_CTC1>, MFC1_FM<6>,
             ISA_FGPU1;

  def MFC1 :   MFC1_FT<"mfc1", GPR32Opnd, FGR32Opnd, II_MFC1,
                                        bitconvert>, MFC1_FM<0>, ISA_FGPU1;
  def MFC1_D64 : MFC1_FT<"mfc1", GPR32Opnd, FGR64Opnd, II_MFC1>, MFC1_FM<0>,
                 ISA_FGPU1, FGR_64 {
    let DecoderNamespace = "FgpuFP64";
  }
  def MTC1 :   MTC1_FT<"mtc1", FGR32Opnd, GPR32Opnd, II_MTC1,
                                        bitconvert>, MFC1_FM<4>, ISA_FGPU1;
  def MTC1_D64 : MTC1_FT<"mtc1", FGR64Opnd, GPR32Opnd, II_MTC1>, MFC1_FM<4>,
                 ISA_FGPU1, FGR_64 {
    let DecoderNamespace = "FgpuFP64";
  }

  def MFHC1_D32 :  MFC1_FT<"mfhc1", GPR32Opnd, AFGR64Opnd, II_MFHC1>,
                  MFC1_FM<3>, ISA_FGPU32R2, FGR_32;
  def MFHC1_D64 : MFC1_FT<"mfhc1", GPR32Opnd, FGR64Opnd, II_MFHC1>,
                  MFC1_FM<3>, ISA_FGPU32R2, FGR_64 {
    let DecoderNamespace = "FgpuFP64";
  }

  def MTHC1_D32 :  
                  MTC1_64_FT<"mthc1", AFGR64Opnd, GPR32Opnd, II_MTHC1>,
                  MFC1_FM<7>, ISA_FGPU32R2, FGR_32;
  def MTHC1_D64 : MTC1_64_FT<"mthc1", FGR64Opnd, GPR32Opnd, II_MTHC1>,
                  MFC1_FM<7>, ISA_FGPU32R2, FGR_64 {
    let DecoderNamespace = "FgpuFP64";
  }

  def DMTC1 : MTC1_FT<"dmtc1", FGR64Opnd, GPR64Opnd, II_DMTC1,
              bitconvert>, MFC1_FM<5>, ISA_FGPU3;
  def DMFC1 : MFC1_FT<"dmfc1", GPR64Opnd, FGR64Opnd, II_DMFC1,
                      bitconvert>, MFC1_FM<1>, ISA_FGPU3;
  let isMoveReg = 1 in {
    def FMOV_S   :  ABSS_FT<"mov.s", FGR32Opnd, FGR32Opnd, II_MOV_S>,
                   ABSS_FM<0x6, 16>, ISA_FGPU1;
    defm FMOV : ABSS_M<"mov.d", II_MOV_D>, ABSS_FM<0x6, 17>, ISA_FGPU1;
  } // isMoveReg


/// Floating Point Memory Instructions
  def LWC1 :  LW_FT<"lwc1", FGR32Opnd, mem_simm16, II_LWC1, load>,
             LW_FM<0x31>, ISA_FGPU1;
  def SWC1 :  SW_FT<"swc1", FGR32Opnd, mem_simm16, II_SWC1, store>,
             LW_FM<0x39>, ISA_FGPU1;


let DecoderNamespace = "FgpuFP64" in {
  def LDC164 :  LW_FT<"ldc1", FGR64Opnd, mem_simm16, II_LDC1, load>,
               LW_FM<0x35>, ISA_FGPU2, FGR_64 {
    let BaseOpcode = "LDC164";
  }
  def SDC164 :  SW_FT<"sdc1", FGR64Opnd, mem_simm16, II_SDC1, store>,
               LW_FM<0x3d>, ISA_FGPU2, FGR_64;
}

  def LDC1 :   LW_FT<"ldc1", AFGR64Opnd, mem_simm16, II_LDC1,
                                      load>, LW_FM<0x35>, ISA_FGPU2, FGR_32 {
    let BaseOpcode = "LDC132";
  }
  def SDC1 :  SW_FT<"sdc1", AFGR64Opnd, mem_simm16, II_SDC1, store>,
             LW_FM<0x3d>, ISA_FGPU2, FGR_32;


// Indexed loads and stores.
// Base register + offset register addressing mode (indicated by "x" in the
// instruction mnemonic) is disallowed under NaCl.
let AdditionalPredicates = [IsNotNaCl] in {
  def LWXC1 :  LWXC1_FT<"lwxc1", FGR32Opnd, II_LWXC1, load>, LWXC1_FM<0>,
              INSN_FGPU4_32R2_NOT_32R6_64R6;
  def SWXC1 :  SWXC1_FT<"swxc1", FGR32Opnd, II_SWXC1, store>, SWXC1_FM<8>,
              INSN_FGPU4_32R2_NOT_32R6_64R6;
}

let AdditionalPredicates = [IsNotNaCl] in {
  def LDXC1 : LWXC1_FT<"ldxc1", AFGR64Opnd, II_LDXC1, load>, LWXC1_FM<1>,
              INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_32;
  def SDXC1 : SWXC1_FT<"sdxc1", AFGR64Opnd, II_SDXC1, store>, SWXC1_FM<9>,
              INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_32;
}

let DecoderNamespace="FgpuFP64" in {
  def LDXC164 : LWXC1_FT<"ldxc1", FGR64Opnd, II_LDXC1, load>, LWXC1_FM<1>,
                INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_64;
  def SDXC164 : SWXC1_FT<"sdxc1", FGR64Opnd, II_SDXC1, store>, SWXC1_FM<9>,
                INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_64;
}

// Load/store doubleword indexed unaligned.
// FIXME: This instruction should not be defined for FGR_32.
let AdditionalPredicates = [IsNotNaCl] in {
  def LUXC1 :  LWXC1_FT<"luxc1", AFGR64Opnd, II_LUXC1>, LWXC1_FM<0x5>,
              INSN_FGPU5_32R2_NOT_32R6_64R6, FGR_32;
  def SUXC1 :  SWXC1_FT<"suxc1", AFGR64Opnd, II_SUXC1>, SWXC1_FM<0xd>,
              INSN_FGPU5_32R2_NOT_32R6_64R6, FGR_32;
}

let AdditionalPredicates = [IsNotNaCl],
    DecoderNamespace="FgpuFP64" in {
  def LUXC164 : LWXC1_FT<"luxc1", FGR64Opnd, II_LUXC1>, LWXC1_FM<0x5>,
                INSN_FGPU5_32R2_NOT_32R6_64R6, FGR_64;
  def SUXC164 : SWXC1_FT<"suxc1", FGR64Opnd, II_SUXC1>, SWXC1_FM<0xd>,
                INSN_FGPU5_32R2_NOT_32R6_64R6, FGR_64;
}

/// Floating-point Arithmetic
  def FADD_S :  ADDS_FT<"add.s", FGR32Opnd, II_ADD_S, 1, fadd>,
               ADDS_FM<0x00, 16>, ISA_FGPU1;
  defm FADD :  ADDS_M<"add.d", II_ADD_D, 1, fadd>, ADDS_FM<0x00, 17>,
               ISA_FGPU1;
  def FDIV_S :  ADDS_FT<"div.s", FGR32Opnd, II_DIV_S, 0, fdiv>,
               ADDS_FM<0x03, 16>, ISA_FGPU1;
  defm FDIV :  ADDS_M<"div.d", II_DIV_D, 0, fdiv>, ADDS_FM<0x03, 17>,
               ISA_FGPU1;
  def FMUL_S :  ADDS_FT<"mul.s", FGR32Opnd, II_MUL_S, 1, fmul>,
               ADDS_FM<0x02, 16>, ISA_FGPU1;
  defm FMUL :  ADDS_M<"mul.d", II_MUL_D, 1, fmul>, ADDS_FM<0x02, 17>,
               ISA_FGPU1;
  def FSUB_S :  ADDS_FT<"sub.s", FGR32Opnd, II_SUB_S, 0, fsub>,
               ADDS_FM<0x01, 16>, ISA_FGPU1;
  defm FSUB :  ADDS_M<"sub.d", II_SUB_D, 0, fsub>, ADDS_FM<0x01, 17>,
               ISA_FGPU1;


let AdditionalPredicates = [HasMadd4] in {
  def MADD_S :  MADDS_FT<"madd.s", FGR32Opnd, II_MADD_S, fadd>,
               MADDS_FM<4, 0>, INSN_FGPU4_32R2_NOT_32R6_64R6;
  def MSUB_S :  MADDS_FT<"msub.s", FGR32Opnd, II_MSUB_S, fsub>,
               MADDS_FM<5, 0>, INSN_FGPU4_32R2_NOT_32R6_64R6;

  def MADD_D32 :  MADDS_FT<"madd.d", AFGR64Opnd, II_MADD_D, fadd>,
                 MADDS_FM<4, 1>, INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_32;
  def MSUB_D32 :  MADDS_FT<"msub.d", AFGR64Opnd, II_MSUB_D, fsub>,
                 MADDS_FM<5, 1>, INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_32;

  let DecoderNamespace = "FgpuFP64" in {
    def MADD_D64 : MADDS_FT<"madd.d", FGR64Opnd, II_MADD_D, fadd>,
                   MADDS_FM<4, 1>, INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_64;
    def MSUB_D64 : MADDS_FT<"msub.d", FGR64Opnd, II_MSUB_D, fsub>,
                   MADDS_FM<5, 1>, INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_64;
  }
}

let AdditionalPredicates = [NoNaNsFPMath, HasMadd4] in {
  def NMADD_S :  NMADDS_FT<"nmadd.s", FGR32Opnd, II_NMADD_S, fadd>,
                MADDS_FM<6, 0>, INSN_FGPU4_32R2_NOT_32R6_64R6;
  def NMSUB_S :  NMADDS_FT<"nmsub.s", FGR32Opnd, II_NMSUB_S, fsub>,
                MADDS_FM<7, 0>, INSN_FGPU4_32R2_NOT_32R6_64R6;

  def NMADD_D32 :  NMADDS_FT<"nmadd.d", AFGR64Opnd, II_NMADD_D, fadd>,
                  MADDS_FM<6, 1>, INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_32;
  def NMSUB_D32 :  NMADDS_FT<"nmsub.d", AFGR64Opnd, II_NMSUB_D, fsub>,
                  MADDS_FM<7, 1>, INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_32;

  let DecoderNamespace = "FgpuFP64" in {
    def NMADD_D64 : NMADDS_FT<"nmadd.d", FGR64Opnd, II_NMADD_D, fadd>,
                    MADDS_FM<6, 1>, INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_64;
    def NMSUB_D64 : NMADDS_FT<"nmsub.d", FGR64Opnd, II_NMSUB_D, fsub>,
                    MADDS_FM<7, 1>, INSN_FGPU4_32R2_NOT_32R6_64R6, FGR_64;
  }
}
//===----------------------------------------------------------------------===//
// Floating Point Branch Codes
//===----------------------------------------------------------------------===//
// Fgpu branch codes. These correspond to condcode in FgpuInstrInfo.h.
// They must be kept in synch.
def FGPU_BRANCH_F  : PatLeaf<(i32 0)>;
def FGPU_BRANCH_T  : PatLeaf<(i32 1)>;

  def BC1F :  BC1F_FT<"bc1f", brtarget, II_BC1F, FGPU_BRANCH_F>,
             BC1F_FM<0, 0>, ISA_FGPU1_NOT_32R6_64R6;
  def BC1FL :  BC1XL_FT<"bc1fl", brtarget, II_BC1FL>,
              BC1F_FM<1, 0>, ISA_FGPU2_NOT_32R6_64R6;
  def BC1T :  BC1F_FT<"bc1t", brtarget, II_BC1T, FGPU_BRANCH_T>,
             BC1F_FM<0, 1>, ISA_FGPU1_NOT_32R6_64R6;
  def BC1TL :  BC1XL_FT<"bc1tl", brtarget, II_BC1TL>,
              BC1F_FM<1, 1>, ISA_FGPU2_NOT_32R6_64R6;

/// Floating Point Compare
  def FCMP_S32 :  CEQS_FT<"s", FGR32, II_C_CC_S, FgpuFPCmp>, CEQS_FM<16>,
                 ISA_FGPU1_NOT_32R6_64R6 {

  // FIXME: This is a required to work around the fact that these instructions
  //        only use $fcc0. Ideally, FgpuFPCmp nodes could be removed and the
  //        fcc register set is used directly.
  bits<3> fcc = 0;
  }
  def FCMP_D32 :  CEQS_FT<"d", AFGR64, II_C_CC_D, FgpuFPCmp>, CEQS_FM<17>,
                 ISA_FGPU1_NOT_32R6_64R6, FGR_32 {
  // FIXME: This is a required to work around the fact that these instructions
  //        only use $fcc0. Ideally, FgpuFPCmp nodes could be removed and the
  //        fcc register set is used directly.
  bits<3> fcc = 0;
  }

let DecoderNamespace = "FgpuFP64" in
def FCMP_D64 : CEQS_FT<"d", FGR64, II_C_CC_D, FgpuFPCmp>, CEQS_FM<17>,
               ISA_FGPU1_NOT_32R6_64R6, FGR_64 {
  // FIXME: This is a required to work around the fact that thiese instructions
  //        only use $fcc0. Ideally, FgpuFPCmp nodes could be removed and the
  //        fcc register set is used directly.
  bits<3> fcc = 0;
}

//===----------------------------------------------------------------------===//
// Floating Point Pseudo-Instructions
//===----------------------------------------------------------------------===//

// This pseudo instr gets expanded into 2 mtc1 instrs after register
// allocation.
class BuildPairF64Base<RegisterOperand RO> :
  PseudoSE<(outs RO:$dst), (ins GPR32Opnd:$lo, GPR32Opnd:$hi),
           [(set RO:$dst, (FgpuBuildPairF64 GPR32Opnd:$lo, GPR32Opnd:$hi))],
           II_MTC1>;

def BuildPairF64 : BuildPairF64Base<AFGR64Opnd>, FGR_32, HARDFLOAT;
def BuildPairF64_64 : BuildPairF64Base<FGR64Opnd>, FGR_64, HARDFLOAT;

// This pseudo instr gets expanded into 2 mfc1 instrs after register
// allocation.
// if n is 0, lower part of src is extracted.
// if n is 1, higher part of src is extracted.
// This node has associated scheduling information as the pre RA scheduler
// asserts otherwise.
class ExtractElementF64Base<RegisterOperand RO> :
  PseudoSE<(outs GPR32Opnd:$dst), (ins RO:$src, i32imm:$n),
           [(set GPR32Opnd:$dst, (FgpuExtractElementF64 RO:$src, imm:$n))],
           II_MFC1>;

def ExtractElementF64 : ExtractElementF64Base<AFGR64Opnd>, FGR_32, HARDFLOAT;
def ExtractElementF64_64 : ExtractElementF64Base<FGR64Opnd>, FGR_64, HARDFLOAT;

def PseudoTRUNC_W_S : FgpuAsmPseudoInst<(outs FGR32Opnd:$fd),
                                        (ins FGR32Opnd:$fs, GPR32Opnd:$rs),
                                        "trunc.w.s\t$fd, $fs, $rs">;

def PseudoTRUNC_W_D32 : FgpuAsmPseudoInst<(outs FGR32Opnd:$fd),
                                          (ins AFGR64Opnd:$fs, GPR32Opnd:$rs),
                                          "trunc.w.d\t$fd, $fs, $rs">,
                        FGR_32, HARDFLOAT;

def PseudoTRUNC_W_D : FgpuAsmPseudoInst<(outs FGR32Opnd:$fd),
                                        (ins FGR64Opnd:$fs, GPR32Opnd:$rs),
                                        "trunc.w.d\t$fd, $fs, $rs">,
                      FGR_64, HARDFLOAT;

def LoadImmSingleGPR : FgpuAsmPseudoInst<(outs GPR32Opnd:$rd),
                                         (ins imm64:$fpimm),
                                         "li.s\t$rd, $fpimm">;

def LoadImmSingleFGR : FgpuAsmPseudoInst<(outs StrictlyFGR32Opnd:$rd),
                                         (ins imm64:$fpimm),
                                         "li.s\t$rd, $fpimm">,
                       HARDFLOAT;

def LoadImmDoubleGPR : FgpuAsmPseudoInst<(outs GPR32Opnd:$rd),
                                         (ins imm64:$fpimm),
                                         "li.d\t$rd, $fpimm">;

def LoadImmDoubleFGR_32 : FgpuAsmPseudoInst<(outs StrictlyAFGR64Opnd:$rd),
                                            (ins imm64:$fpimm),
                                            "li.d\t$rd, $fpimm">,
                          FGR_32, HARDFLOAT;

def LoadImmDoubleFGR : FgpuAsmPseudoInst<(outs StrictlyFGR64Opnd:$rd),
                                         (ins imm64:$fpimm),
                                         "li.d\t$rd, $fpimm">,
                       FGR_64, HARDFLOAT;

def SDC1_M1 : FgpuAsmPseudoInst<(outs AFGR64Opnd:$fd),
                                (ins mem_simm16:$addr),
                                "s.d\t$fd, $addr">,
              FGR_32, ISA_FGPU1, HARDFLOAT;

//===----------------------------------------------------------------------===//
// InstAliases.
//===----------------------------------------------------------------------===//
def : FgpuInstAlias
        <"s.s $fd, $addr", (SWC1 FGR32Opnd:$fd, mem_simm16:$addr), 0>,
      ISA_FGPU2, HARDFLOAT;
def : FgpuInstAlias
        <"s.d $fd, $addr", (SDC1 AFGR64Opnd:$fd, mem_simm16:$addr), 0>,
      FGR_32, ISA_FGPU2, HARDFLOAT;
def : FgpuInstAlias
        <"s.d $fd, $addr", (SDC164 FGR64Opnd:$fd, mem_simm16:$addr), 0>,
      FGR_64, ISA_FGPU2, HARDFLOAT;
def : FgpuInstAlias
        <"s.d $fd, $addr", (SDC1_M1 AFGR64Opnd:$fd, mem_simm16:$addr), 0>,
      FGR_32, ISA_FGPU1, HARDFLOAT;

def : FgpuInstAlias
        <"l.s $fd, $addr", (LWC1 FGR32Opnd:$fd, mem_simm16:$addr), 0>,
      ISA_FGPU2, HARDFLOAT;
def : FgpuInstAlias
        <"l.d $fd, $addr", (LDC1 AFGR64Opnd:$fd, mem_simm16:$addr), 0>,
      FGR_32, ISA_FGPU2, HARDFLOAT;
def : FgpuInstAlias
        <"l.d $fd, $addr", (LDC164 FGR64Opnd:$fd, mem_simm16:$addr), 0>,
      FGR_64, ISA_FGPU2, HARDFLOAT;

multiclass C_COND_ALIASES<string TypeStr, RegisterOperand RC> {
  def : FgpuInstAlias<!strconcat("c.f.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_F_"#NAME) FCC0,
                                                       RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.un.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_UN_"#NAME) FCC0,
                                                        RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.eq.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_EQ_"#NAME) FCC0,
                                                        RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.ueq.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_UEQ_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.olt.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_OLT_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.ult.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_ULT_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.ole.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_OLE_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.ule.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_ULE_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.sf.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_SF_"#NAME) FCC0,
                                                        RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.ngle.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_NGLE_"#NAME) FCC0,
                                                          RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.seq.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_SEQ_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.ngl.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_NGL_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.lt.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_LT_"#NAME) FCC0,
                                                        RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.nge.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_NGE_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.le.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_LE_"#NAME) FCC0,
                                                        RC:$fs, RC:$ft), 1>;
  def : FgpuInstAlias<!strconcat("c.ngt.", TypeStr, " $fs, $ft"),
                      (!cast<Instruction>("C_NGT_"#NAME) FCC0,
                                                         RC:$fs, RC:$ft), 1>;
}

multiclass BC1_ALIASES<Instruction BCTrue, string BCTrueString,
                       Instruction BCFalse, string BCFalseString> {
  def : FgpuInstAlias<!strconcat(BCTrueString, " $offset"),
                                (BCTrue FCC0, brtarget:$offset), 1>;

  def : FgpuInstAlias<!strconcat(BCFalseString, " $offset"),
                                (BCFalse FCC0, brtarget:$offset), 1>;
}

  defm S   : C_COND_ALIASES<"s", FGR32Opnd>, HARDFLOAT,
             ISA_FGPU1_NOT_32R6_64R6;
  defm D32 : C_COND_ALIASES<"d", AFGR64Opnd>, HARDFLOAT,
             ISA_FGPU1_NOT_32R6_64R6, FGR_32;
  defm D64 : C_COND_ALIASES<"d", FGR64Opnd>, HARDFLOAT,
             ISA_FGPU1_NOT_32R6_64R6, FGR_64;

  defm : BC1_ALIASES<BC1T, "bc1t", BC1F, "bc1f">, ISA_FGPU1_NOT_32R6_64R6,
         HARDFLOAT;
  defm : BC1_ALIASES<BC1TL, "bc1tl", BC1FL, "bc1fl">, ISA_FGPU2_NOT_32R6_64R6,
         HARDFLOAT;

//===----------------------------------------------------------------------===//
// Floating Point Patterns
//===----------------------------------------------------------------------===//
def : FgpuPat<(f32 fpimm0), (MTC1 ZERO)>, ISA_FGPU1;
def : FgpuPat<(f32 fpimm0neg), (FNEG_S (MTC1 ZERO))>, ISA_FGPU1;

def : FgpuPat<(f32 (sint_to_fp GPR32Opnd:$src)),
              (PseudoCVT_S_W GPR32Opnd:$src)>;
def : FgpuPat<(FgpuTruncIntFP FGR32Opnd:$src),
              (TRUNC_W_S FGR32Opnd:$src)>, ISA_FGPU1;

def : FgpuPat<(FgpuMTC1_D64 GPR32Opnd:$src),
              (MTC1_D64 GPR32Opnd:$src)>, ISA_FGPU1, FGR_64;

def : FgpuPat<(f64 (sint_to_fp GPR32Opnd:$src)),
              (PseudoCVT_D32_W GPR32Opnd:$src)>, FGR_32;
  def : FgpuPat<(FgpuTruncIntFP AFGR64Opnd:$src),
                (TRUNC_W_D32 AFGR64Opnd:$src)>, ISA_FGPU2, FGR_32;
  def : FgpuPat<(f32 (fpround AFGR64Opnd:$src)),
                (CVT_S_D32 AFGR64Opnd:$src)>, ISA_FGPU1, FGR_32;
  def : FgpuPat<(f64 (fpextend FGR32Opnd:$src)),
                (CVT_D32_S FGR32Opnd:$src)>, ISA_FGPU1, FGR_32;


def : FgpuPat<(f64 fpimm0), (DMTC1 ZERO_64)>, ISA_FGPU3, GPR_64, FGR_64;
def : FgpuPat<(f64 fpimm0neg), (FNEG_D64 (DMTC1 ZERO_64))>, ISA_FGPU3, GPR_64,
      FGR_64;

def : FgpuPat<(f64 (sint_to_fp GPR32Opnd:$src)),
              (PseudoCVT_D64_W GPR32Opnd:$src)>, FGR_64;
def : FgpuPat<(f32 (sint_to_fp GPR64Opnd:$src)),
              (EXTRACT_SUBREG (PseudoCVT_S_L GPR64Opnd:$src), sub_lo)>, FGR_64;
def : FgpuPat<(f64 (sint_to_fp GPR64Opnd:$src)),
              (PseudoCVT_D64_L GPR64Opnd:$src)>, FGR_64;

def : FgpuPat<(FgpuTruncIntFP FGR64Opnd:$src),
              (TRUNC_W_D64 FGR64Opnd:$src)>, ISA_FGPU2, FGR_64;
def : FgpuPat<(FgpuTruncIntFP FGR32Opnd:$src),
              (TRUNC_L_S FGR32Opnd:$src)>, ISA_FGPU2, FGR_64;
def : FgpuPat<(FgpuTruncIntFP FGR64Opnd:$src),
              (TRUNC_L_D64 FGR64Opnd:$src)>, ISA_FGPU2, FGR_64;

  def : FgpuPat<(f32 (fpround FGR64Opnd:$src)),
                (CVT_S_D64 FGR64Opnd:$src)>, ISA_FGPU1, FGR_64;
  def : FgpuPat<(f64 (fpextend FGR32Opnd:$src)),
                (CVT_D64_S FGR32Opnd:$src)>, ISA_FGPU1, FGR_64;

// To generate NMADD and NMSUB instructions when fneg node is present
multiclass NMADD_NMSUB<Instruction Nmadd, Instruction Nmsub, RegisterOperand RC> {
  def : FgpuPat<(fneg (fadd (fmul RC:$fs, RC:$ft), RC:$fr)),
                (Nmadd RC:$fr, RC:$fs, RC:$ft)>;
  def : FgpuPat<(fneg (fsub (fmul RC:$fs, RC:$ft), RC:$fr)),
                (Nmsub RC:$fr, RC:$fs, RC:$ft)>;
}

let AdditionalPredicates = [NoNaNsFPMath, HasMadd4] in {
  defm : NMADD_NMSUB<NMADD_S, NMSUB_S, FGR32Opnd>,
         INSN_FGPU4_32R2_NOT_32R6_64R6;
  defm : NMADD_NMSUB<NMADD_D32, NMSUB_D32, AFGR64Opnd>,
         FGR_32, INSN_FGPU4_32R2_NOT_32R6_64R6;
  defm : NMADD_NMSUB<NMADD_D64, NMSUB_D64, FGR64Opnd>,
         FGR_64, INSN_FGPU4_32R2_NOT_32R6_64R6;
}

// Patterns for loads/stores with a reg+imm operand.
  let AddedComplexity = 40 in {
    def : LoadRegImmPat<LWC1, f32, load>, ISA_FGPU1;
    def : StoreRegImmPat<SWC1, f32>, ISA_FGPU1;

    def : LoadRegImmPat<LDC164, f64, load>, ISA_FGPU1, FGR_64;
    def : StoreRegImmPat<SDC164, f64>, ISA_FGPU1, FGR_64;

    def : LoadRegImmPat<LDC1, f64, load>, ISA_FGPU1, FGR_32;
    def : StoreRegImmPat<SDC1, f64>, ISA_FGPU1, FGR_32;
  }

